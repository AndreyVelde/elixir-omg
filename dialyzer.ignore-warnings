apps/omg_performance/
apps/omg/test
apps/omg_eth/test

# TODO
The success typing for 'Elixir.OMG.Crypto':decode_address/1 implies that the function might also return 'error' but the specification return is {'error','bad_address_encoding'} | {'ok',<<_:160>>}
Type specification 'Elixir.OMG.EthereumClientMonitor':check() -> non_neg_integer() | 'error' is a subtype of the success typing: 'Elixir.OMG.EthereumClientMonitor':check() -> any()
Type specification 'Elixir.OMG.EthereumClientMonitor':raise_clear(module(),boolean(),'error' | non_neg_integer()) -> 'ok' | 'duplicate' is a subtype of the success typing: 'Elixir.OMG.EthereumClientMonitor':raise_clear(_,boolean(),'error' | non_neg_integer()) -> any()
Type specification 'Elixir.OMG.Fees':'covered?'(input_amounts::map(),output_amounts::map(),fees::fee_t()) -> boolean() is a subtype of the success typing: 'Elixir.OMG.Fees':'covered?'(_,_,_) -> boolean()
Type specification 'Elixir.OMG.Fees':for_tx('Elixir.OMG.State.Transaction.Recovered':t(),fee_t()) -> fee_t() is a subtype of the success typing: 'Elixir.OMG.Fees':for_tx(_,_) -> any()
Type specification 'Elixir.OMG.Fees':parse_file_content(binary()) -> {'ok',fee_t()} | {'error',[{'error',atom()}]} is not equal to the success typing: 'Elixir.OMG.Fees':parse_file_content(binary() | maybe_improper_list(binary() | maybe_improper_list(any(),binary() | []) | byte(),binary() | [])) -> {'error',[any(),...]} | {'ok',_}
Type specification 'Elixir.OMG.RootChainCoordinator':start_link('Elixir.OMG.RootChainCoordinator.Core':configs_services()) -> 'Elixir.GenServer':on_start() is a subtype of the success typing: 'Elixir.OMG.RootChainCoordinator':start_link(_) -> 'ignore' | {'error',_} | {'ok',pid()}
Type specification 'Elixir.OMG.RootChainCoordinator':check_in(non_neg_integer(),atom()) -> 'ok' is a subtype of the success typing: 'Elixir.OMG.RootChainCoordinator':check_in(_,_) -> any()
Type specification 'Elixir.OMG.RootChainCoordinator':get_sync_info() -> 'Elixir.OMG.RootChainCoordinator.SyncGuide':t() | 'nosync' is a subtype of the success typing: 'Elixir.OMG.RootChainCoordinator':get_sync_info() -> any()
Type specification 'Elixir.OMG.RootChainCoordinator':get_ethereum_heights() -> {'ok','Elixir.OMG.RootChainCoordinator.Core':ethereum_heights_result_t()} is a subtype of the success typing: 'Elixir.OMG.RootChainCoordinator':get_ethereum_heights() -> any()
Type specification 'Elixir.OMG.Signature':recover_public(keccak_hash(),hash_v(),hash_r(),hash_s(),integer() | 'nil') -> {'ok',public_key()} | {'error','Elixir.String':t()} is not equal to the success typing: 'Elixir.OMG.Signature':recover_public(binary(),integer(),non_neg_integer(),non_neg_integer(),_) -> {'error',binary()} | {'ok',binary()}
Type specification 'Elixir.OMG.Signature':'uses_chain_id?'(hash_v()) -> boolean() is a subtype of the success typing: 'Elixir.OMG.Signature':'uses_chain_id?'(_) -> boolean()
Type specification 'Elixir.OMG.State':exec(tx::'Elixir.OMG.State.Transaction.Recovered':t(),fees::'Elixir.OMG.Fees':fee_t()) -> {'ok',{'Elixir.OMG.State.Transaction':tx_hash(),pos_integer(),non_neg_integer()}} | {'error',exec_error()} is a subtype of the success typing: 'Elixir.OMG.State':exec(_,_) -> any()
Type specification 'Elixir.OMG.State':close_block(pos_integer()) -> {'ok',['Elixir.OMG.State.Core':db_update()]} is a subtype of the success typing: 'Elixir.OMG.State':close_block(_) -> any()
Type specification 'Elixir.OMG.State':deposit(deposits::['Elixir.OMG.State.Core':deposit()]) -> {'ok',['Elixir.OMG.State.Core':db_update()]} is a subtype of the success typing: 'Elixir.OMG.State':deposit(_) -> any()
Type specification 'Elixir.OMG.State':exit_utxos(utxos::'Elixir.OMG.State.Core':exiting_utxos_t()) -> {'ok',['Elixir.OMG.State.Core':db_update()],'Elixir.OMG.State.Core':validities_t()} is a subtype of the success typing: 'Elixir.OMG.State':exit_utxos(_) -> any()
Type specification 'Elixir.OMG.State':'utxo_exists?'('Elixir.OMG.Utxo.Position':t()) -> boolean() is a subtype of the success typing: 'Elixir.OMG.State':'utxo_exists?'(_) -> any()
Type specification 'Elixir.OMG.State':get_status() -> {non_neg_integer(),boolean()} is a subtype of the success typing: 'Elixir.OMG.State':get_status() -> any()
Type specification 'Elixir.OMG.State.Core':standard_exitable_utxos([{'Elixir.OMG.DB':utxo_pos_db_t(),'Elixir.OMG.Utxo':t()}],'Elixir.OMG.Crypto':address_t()) -> [exitable_utxos()] is a subtype of the success typing: 'Elixir.OMG.State.Core':standard_exitable_utxos(_,_) -> [any()]
Type specification 'Elixir.OMG.State.Transaction':parse_address(<<>> | 'Elixir.OMG.Crypto':address_t()) -> {'ok','Elixir.OMG.Crypto':address_t()} | {'error','malformed_address'} is a subtype of the success typing: 'Elixir.OMG.State.Transaction':parse_address(_) -> {'error','malformed_address'} | {'ok',<<_:160>>}
Type specification 'Elixir.OMG.TypedDataHash.Tools':domain_separator(binary(),binary(),'Elixir.OMG.Crypto':address_t(),'Elixir.OMG.Crypto':hash_t()) -> 'Elixir.OMG.Crypto':hash_t() is a subtype of the success typing: 'Elixir.OMG.TypedDataHash.Tools':domain_separator(binary() | maybe_improper_list(binary() | maybe_improper_list(any(),binary() | []) | byte(),binary() | []),binary() | maybe_improper_list(binary() | maybe_improper_list(any(),binary() | []) | byte(),binary() | []),_,_) -> binary()
Type specification 'Elixir.OMG.TypedDataHash.Tools':hash_transaction(['Elixir.OMG.Utxo.Position':t()],['Elixir.OMG.State.Transaction':output()],'Elixir.OMG.State.Transaction':metadata(),'Elixir.OMG.Crypto':hash_t(),'Elixir.OMG.Crypto':hash_t()) -> 'Elixir.OMG.Crypto':hash_t() is a subtype of the success typing: 'Elixir.OMG.TypedDataHash.Tools':hash_transaction(_,_,_,_,_) -> binary()
Type specification 'Elixir.OMG.TypedDataHash.Tools':hash_input('Elixir.OMG.Utxo.Position':t()) -> 'Elixir.OMG.Crypto':hash_t() is a subtype of the success typing: 'Elixir.OMG.TypedDataHash.Tools':hash_input({'utxo_position',_,_,_}) -> binary()
The success typing for 'Elixir.OMG.ChildChain.BlockQueue.Core':first_to_mined/1 implies that the function might also return float() but the specification return is pos_integer()
Type specification 'Elixir.OMG.ChildChain.BlockQueue.Core':child_block_nums_to_init_with(non_neg_integer(),non_neg_integer(),pos_integer(),non_neg_integer()) -> [any()] is not equal to the success typing: 'Elixir.OMG.ChildChain.BlockQueue.Core':child_block_nums_to_init_with(number(),_,number(),number()) -> [integer()]
Type specification 'Elixir.OMG.ChildChain.BlockQueue.Core':process_submit_result('Elixir.OMG.ChildChain.BlockQueue.Core.BlockSubmission':t(),submit_result_t(),'Elixir.OMG.ChildChain.BlockQueue.Core.BlockSubmission':plasma_block_num()) -> 'ok' | {'error',atom()} is not equal to the success typing: 'Elixir.OMG.ChildChain.BlockQueue.Core':process_submit_result(_,{'error',map()} | {'ok',_},_) -> 'ok' | {'error','account_locked' | 'nonce_too_low'}
Type specification 'Elixir.OMG.ChildChain.FeeServer':transaction_fees() -> {'ok','Elixir.OMG.Fees':fee_t()} is a subtype of the success typing: 'Elixir.OMG.ChildChain.FeeServer':transaction_fees() -> {'ok',_}
Type specification 'Elixir.OMG.ChildChain.FreshBlocks':get(block_hash::binary()) -> {'ok','Elixir.OMG.Block':t()} | {'error','not_found' | any()} is a subtype of the success typing: 'Elixir.OMG.ChildChain.FreshBlocks':get(_) -> any()
Type specification 'Elixir.OMG.ChildChain.FreshBlocks':push('Elixir.OMG.Block':t()) -> 'ok' is a subtype of the success typing: 'Elixir.OMG.ChildChain.FreshBlocks':push(_) -> 'ok'
Type specification 'Elixir.OMG.ChildChain.Monitor':pop_child_from_dead_pid(pid(),['Elixir.OMG.ChildChain.Monitor.Child':t()]) -> {'Elixir.OMG.ChildChain.Monitor.Child':t(),['Elixir.OMG.ChildChain.Monitor.Child':t()]} | {'nil',['Elixir.OMG.ChildChain.Monitor.Child':t()]} is a subtype of the success typing: 'Elixir.OMG.ChildChain.Monitor':pop_child_from_dead_pid(_,[any()]) -> {_,[any()]}
Type specification 'Elixir.OMG.DB.LevelDB':blocks(block_to_fetch::[any()],atom()) -> {'ok',[any()]} | {'error',any()} is a subtype of the success typing: 'Elixir.OMG.DB.LevelDB':blocks(_,_) -> any()
Type specification 'Elixir.OMG.DB.LevelDB':exit_info({pos_integer(),non_neg_integer(),non_neg_integer()},atom()) -> {'ok',map()} | {'error',atom()} is a subtype of the success typing: 'Elixir.OMG.DB.LevelDB':exit_info(_,atom() | pid() | {atom(),_} | {'via',atom(),_}) -> any()
Type specification 'Elixir.OMG.DB.LevelDB':spent_blknum(utxo_pos_db_t(),atom()) -> {'ok',pos_integer()} | {'error',atom()} is a subtype of the success typing: 'Elixir.OMG.DB.LevelDB':spent_blknum(_,atom() | pid() | {atom(),_} | {'via',atom(),_}) -> any()
Type specification 'Elixir.OMG.DB.LevelDB.Core':decode_value({'ok',binary()} | 'not_found',atom()) -> {'ok',term()} | {'error',term()} is a subtype of the success typing: 'Elixir.OMG.DB.LevelDB.Core':decode_value(_,_) -> {'error',_} | {'ok',_}
The success typing for 'Elixir.OMG.DB.LevelDB.Core':decode_values/2 implies that the function might also return {'error',[any()]} but the specification return is {'ok',[any()]}
Type specification 'Elixir.OMG.DB.LevelDB.Recorder':update_write(atom()) -> integer() is a subtype of the success typing: 'Elixir.OMG.DB.LevelDB.Recorder':update_write(atom() | ets:tid()) -> integer()
Type specification 'Elixir.OMG.DB.LevelDB.Recorder':update_read(atom()) -> integer() is a subtype of the success typing: 'Elixir.OMG.DB.LevelDB.Recorder':update_read(atom() | ets:tid()) -> integer()
Type specification 'Elixir.OMG.DB.LevelDB.Recorder':update_multiread(atom()) -> integer() is a subtype of the success typing: 'Elixir.OMG.DB.LevelDB.Recorder':update_multiread(atom() | ets:tid()) -> integer()
The success typing for 'Elixir.OMG.DB.LevelDB.Server':init_storage/1 implies that the function might also return 'false' but the specification return is 'ok' | {'error',atom()}
The success typing for 'Elixir.OMG.DB.LevelDB.Server':get/2 implies that the function might also return {'error',_} but the specification return is 'not_found' | {'ok',binary()}
Type specification 'Elixir.OMG.DB.RocksDB':blocks(block_to_fetch::[any()],atom()) -> {'ok',[any()]} | {'error',any()} is a subtype of the success typing: 'Elixir.OMG.DB.RocksDB':blocks(_,_) -> any()
Type specification 'Elixir.OMG.DB.RocksDB':exit_info({pos_integer(),non_neg_integer(),non_neg_integer()},atom()) -> {'ok',map()} | {'error',atom()} is a subtype of the success typing: 'Elixir.OMG.DB.RocksDB':exit_info(_,atom() | pid() | {atom(),_} | {'via',atom(),_}) -> any()
Type specification 'Elixir.OMG.DB.RocksDB':spent_blknum(utxo_pos_db_t(),atom()) -> {'ok',pos_integer()} | {'error',atom()} is a subtype of the success typing: 'Elixir.OMG.DB.RocksDB':spent_blknum(_,atom() | pid() | {atom(),_} | {'via',atom(),_}) -> any()
Type specification 'Elixir.OMG.DB.RocksDB.Core':decode_value({'ok',binary()} | 'not_found',atom()) -> {'ok',term()} | 'not_found' is a subtype of the success typing: 'Elixir.OMG.DB.RocksDB.Core':decode_value('not_found' | binary() | {'ok',binary()},_) -> 'not_found' | {'ok',_}
Type specification 'Elixir.OMG.DB.RocksDB.Core':decode_values('Elixir.Enumerable':t(),atom()) -> {'ok',[any()]} is a subtype of the success typing: 'Elixir.OMG.DB.RocksDB.Core':decode_values(_,_) -> {'ok',[any()]}
Type specification 'Elixir.OMG.DB.RocksDB.Recorder':update_write(atom()) -> integer() is a subtype of the success typing: 'Elixir.OMG.DB.RocksDB.Recorder':update_write(atom() | ets:tid()) -> integer()
Type specification 'Elixir.OMG.DB.RocksDB.Recorder':update_read(atom()) -> integer() is a subtype of the success typing: 'Elixir.OMG.DB.RocksDB.Recorder':update_read(atom() | ets:tid()) -> integer()
Type specification 'Elixir.OMG.DB.RocksDB.Recorder':update_multiread(atom()) -> integer() is a subtype of the success typing: 'Elixir.OMG.DB.RocksDB.Recorder':update_multiread(atom() | ets:tid()) -> integer()
The success typing for 'Elixir.OMG.DB.RocksDB.Server':init_storage/1 implies that the function might also return 'false' but the specification return is 'ok' | {'error',atom()}
The success typing for 'Elixir.OMG.DB.RocksDB.Server':get/2 implies that the function might also return {'error',_} but the specification return is 'not_found' | {'ok',binary()}
Type specification 'Elixir.OMG.Eth':get_call_data(binary(),binary(),[atom()],[atom()]) -> map() is a subtype of the success typing: 'Elixir.OMG.Eth':get_call_data(binary() | non_neg_integer(),_,_,_) -> map()
Type specification 'Elixir.OMG.Eth.Encoding':to_hex(binary() | non_neg_integer()) -> binary() is not equal to the success typing: 'Elixir.OMG.Eth.Encoding':to_hex(binary() | integer()) -> <<_:16,_:_*8>>
Type specification 'Elixir.OMG.Eth.Encoding':int_from_hex(<<_:16,_:_*8>>) -> non_neg_integer() is a subtype of the success typing: 'Elixir.OMG.Eth.Encoding':int_from_hex(<<_:16,_:_*8>>) -> integer()
Type specification 'Elixir.OMG.Eth.RootChain':submit_block(binary(),pos_integer(),pos_integer(),optional_addr_t(),optional_addr_t()) -> {'error',binary() | atom() | map()} | {'ok',binary()} is not equal to the success typing: 'Elixir.OMG.Eth.RootChain':submit_block(_,_,_,'false' | 'nil' | <<_:160>>,'false' | 'nil' | <<_:160>>) -> {'error',atom() | binary() | map()} | {'ok',<<_:256>>}
Type specification 'Elixir.OMG.Eth.RootChain':get_child_block_interval() -> {'ok',pos_integer()} | 'error' is a subtype of the success typing: 'Elixir.OMG.Eth.RootChain':get_child_block_interval() -> 'error' | {'ok',_}
Type specification 'Elixir.OMG.Eth.RootChain':get_piggybacks(non_neg_integer(),non_neg_integer(),optional_addr_t()) -> {'ok',[in_flight_exit_piggybacked_event()]} is a subtype of the success typing: 'Elixir.OMG.Eth.RootChain':get_piggybacks(_,_,_) -> any()
Type specification 'Elixir.OMG.Eth.RootChain':contract_ready(optional_addr_t()) -> 'ok' | {'error','root_chain_contract_not_available' | 'root_chain_authority_is_nil'} is a subtype of the success typing: 'Elixir.OMG.Eth.RootChain':contract_ready(_) -> 'ok' | {'error','root_chain_authority_is_nil' | 'root_chain_contract_not_available'}
Type specification 'Elixir.OMG.Utils.HttpRPC.Encoding':from_hex(<<_:16,_:_*8>>) -> {'ok',binary()} | {'error','invalid_hex'} is a subtype of the success typing: 'Elixir.OMG.Utils.HttpRPC.Encoding':from_hex(_) -> {'error','invalid_hex'} | {'ok',binary()}
Type specification 'Elixir.OMG.Utils.HttpRPC.Validator.Base':expect(map(),atom() | binary(),atom() | [any()]) -> {'ok',any()} | validation_error_t() is a subtype of the success typing: 'Elixir.OMG.Utils.HttpRPC.Validator.Base':expect(map(),_,_) -> {'error',{'validation_error',binary(),_}} | {'ok',_}
Type specification 'Elixir.OMG.Utils.HttpRPC.Validator.Base':integer({any(),[any()]}) -> {any(),[any()]} is a subtype of the success typing: 'Elixir.OMG.Utils.HttpRPC.Validator.Base':integer({_,maybe_improper_list()}) -> {_,maybe_improper_list()}
Type specification 'Elixir.OMG.Utils.HttpRPC.Validator.Base':optional({any(),[any()]}) -> {any(),[any()]} is a subtype of the success typing: 'Elixir.OMG.Utils.HttpRPC.Validator.Base':optional(_) -> any()
Type specification 'Elixir.OMG.Utils.HttpRPC.Validator.Base':hex({any(),[any()]}) -> {any(),[any()]} is a subtype of the success typing: 'Elixir.OMG.Utils.HttpRPC.Validator.Base':hex({_,maybe_improper_list()}) -> {_,maybe_improper_list()}
Type specification 'Elixir.OMG.Utils.HttpRPC.Validator.Base':length({any(),[any()]},non_neg_integer()) -> {any(),[any()]} is a subtype of the success typing: 'Elixir.OMG.Utils.HttpRPC.Validator.Base':length({_,maybe_improper_list()},_) -> {_,maybe_improper_list()}
Type specification 'Elixir.OMG.Utils.HttpRPC.Validator.Base':greater({any(),[any()]},integer()) -> {any(),[any()]} is a subtype of the success typing: 'Elixir.OMG.Utils.HttpRPC.Validator.Base':greater({_,maybe_improper_list()},_) -> {_,maybe_improper_list()}
Type specification 'Elixir.OMG.Utils.HttpRPC.Validator.Base':list({any(),[any()]}) -> {any(),[any()]} is a subtype of the success typing: 'Elixir.OMG.Utils.HttpRPC.Validator.Base':list({_,_}) -> {_,maybe_improper_list()}
Type specification 'Elixir.OMG.Watcher.API.InFlightExit':get_in_flight_exit(binary()) -> {'ok',in_flight_exit()} | {'error',atom()} is a subtype of the success typing: 'Elixir.OMG.Watcher.API.InFlightExit':get_in_flight_exit(_) -> any()
Type specification 'Elixir.OMG.Watcher.API.Status':get_status() -> {'ok',t()} is a subtype of the success typing: 'Elixir.OMG.Watcher.API.Status':get_status() -> any()
Type specification 'Elixir.OMG.Watcher.API.Transaction':submit(binary()) -> 'Elixir.OMG.Watcher.HttpRPC.Client':response_t() is a subtype of the success typing: 'Elixir.OMG.Watcher.API.Transaction':submit(_) -> any()
Type specification 'Elixir.OMG.Watcher.API.Transaction':create('Elixir.OMG.Watcher.UtxoSelection':order_t()) -> 'Elixir.OMG.Watcher.UtxoSelection':advice_t() is a subtype of the success typing: 'Elixir.OMG.Watcher.API.Transaction':create(_) -> any()
Type specification 'Elixir.OMG.Watcher.API.Utxo':compose_utxo_exit('Elixir.OMG.Utxo.Position':t()) -> {'ok','Elixir.OMG.Watcher.DB.TxOutput':exit_t()} | {'error','utxo_not_found'} is a subtype of the success typing: 'Elixir.OMG.Watcher.API.Utxo':compose_utxo_exit(_) -> any()
Type specification 'Elixir.OMG.Watcher.API.Utxo':create_challenge('Elixir.OMG.Utxo.Position':t()) -> {'ok','Elixir.OMG.Watcher.ExitProcessor.StandardExitChallenge':t()} | {'error','utxo_not_spent'} | {'error','exit_not_found'} is a subtype of the success typing: 'Elixir.OMG.Watcher.API.Utxo':create_challenge(_) -> any()
Type specification 'Elixir.OMG.Watcher.BlockGetter':get_events() -> {'ok','Elixir.OMG.Watcher.BlockGetter.Core':chain_ok_response_t()} is a subtype of the success typing: 'Elixir.OMG.Watcher.BlockGetter':get_events() -> {'ok',{'error',[map()]} | {'ok',[map()]}}
Type specification 'Elixir.OMG.Watcher.BlockGetter':handle_info('producer' | {reference(),{'downloaded_block',{'ok',map()}}} | {reference(),{'downloaded_block',{'error','Elixir.OMG.Watcher.BlockGetter.Core':block_error()}}} | {'DOWN',reference(),'process',pid(),'normal'},'Elixir.OMG.Watcher.BlockGetter.Core':t()) -> {'noreply','Elixir.OMG.Watcher.BlockGetter.Core':t()} | {'stop','normal','Elixir.OMG.Watcher.BlockGetter.Core':t()} is a subtype of the success typing: 'Elixir.OMG.Watcher.BlockGetter':handle_info('producer' | 'sync' | {_,{'downloaded_block',_}} | {'DOWN',_,'process',_,'normal'},_) -> any()
Type specification 'Elixir.OMG.Watcher.BlockGetter.Status':update('Elixir.OMG.Watcher.BlockGetter.Core':chain_ok_response_t()) -> 'ok' is a subtype of the success typing: 'Elixir.OMG.Watcher.BlockGetter.Status':update(_) -> 'ok'
Type specification 'Elixir.OMG.Watcher.BlockGetter.Status':get_events() -> {'ok','Elixir.OMG.Watcher.BlockGetter.Core':chain_ok_response_t()} is a subtype of the success typing: 'Elixir.OMG.Watcher.BlockGetter.Status':get_events() -> any()
The success typing for 'Elixir.Phoenix.Param.OMG.Watcher.DB.Block':'__impl__'/1 implies that the function might also return 'Elixir.Phoenix.Param' | 'Elixir.Phoenix.Param.OMG.Watcher.DB.Block' but the specification return is 'Elixir.OMG.Watcher.DB.Block'
The success typing for 'Elixir.Phoenix.Param.OMG.Watcher.DB.EthEvent':'__impl__'/1 implies that the function might also return 'Elixir.Phoenix.Param' | 'Elixir.Phoenix.Param.OMG.Watcher.DB.EthEvent' but the specification return is 'Elixir.OMG.Watcher.DB.EthEvent'
Type specification 'Elixir.OMG.Watcher.DB.EthEvent':'insert_deposits!'(['Elixir.OMG.State.Core':deposit()]) -> 'ok' is a subtype of the success typing: 'Elixir.OMG.Watcher.DB.EthEvent':'insert_deposits!'(_) -> 'ok'
Type specification 'Elixir.OMG.Watcher.DB.EthEvent':'insert_exits!'([non_neg_integer()]) -> 'ok' is a subtype of the success typing: 'Elixir.OMG.Watcher.DB.EthEvent':'insert_exits!'(_) -> 'ok'
Type specification 'Elixir.OMG.Watcher.DB.EthEvent':generate_unique_key('Elixir.OMG.Utxo.Position':t(),'deposit' | 'exit') -> 'Elixir.OMG.Crypto':hash_t() is a subtype of the success typing: 'Elixir.OMG.Watcher.DB.EthEvent':generate_unique_key({'utxo_position',non_neg_integer(),non_neg_integer(),non_neg_integer()},_) -> binary()
Type specification 'Elixir.OMG.Watcher.DB.Repo':rollback(term()) -> no_return() is a subtype of the success typing: 'Elixir.OMG.Watcher.DB.Repo':rollback(_) -> any()
Type specification 'Elixir.OMG.Watcher.DB.Repo':insert_all_chunked(schema_or_source::binary() | atom() | 'Elixir.Ecto.Schema':t(),entries::[map() | 'Elixir.Keyword':t()],opts::'Elixir.Keyword':t()) -> 'ok' is a subtype of the success typing: 'Elixir.OMG.Watcher.DB.Repo':insert_all_chunked(_,maybe_improper_list(),_) -> 'ok'
The success typing for 'Elixir.Jason.Encoder.OMG.Watcher.DB.Transaction':'__impl__'/1 implies that the function might also return 'Elixir.Jason.Encoder' | 'Elixir.Jason.Encoder.OMG.Watcher.DB.Transaction' but the specification return is 'Elixir.OMG.Watcher.DB.Transaction'
The success typing for 'Elixir.Phoenix.Param.OMG.Watcher.DB.Transaction':'__impl__'/1 implies that the function might also return 'Elixir.Phoenix.Param' | 'Elixir.Phoenix.Param.OMG.Watcher.DB.Transaction' but the specification return is 'Elixir.OMG.Watcher.DB.Transaction'
Type specification 'Elixir.OMG.Watcher.DB.TxOutput':compose_utxo_exit('Elixir.OMG.Utxo.Position':t()) -> {'ok',exit_t()} | {'error','utxo_not_found'} is a subtype of the success typing: 'Elixir.OMG.Watcher.DB.TxOutput':compose_utxo_exit({'utxo_position',_,_,_}) -> any()
Type specification 'Elixir.OMG.Watcher.DB.TxOutput':get_by_position('Elixir.OMG.Utxo.Position':t()) -> map() | 'nil' is a subtype of the success typing: 'Elixir.OMG.Watcher.DB.TxOutput':get_by_position({'utxo_position',_,_,_}) -> any()
Type specification 'Elixir.OMG.Watcher.DB.TxOutput':get_balance('Elixir.OMG.Crypto':address_t()) -> [balance()] is a subtype of the success typing: 'Elixir.OMG.Watcher.DB.TxOutput':get_balance(_) -> any()
Type specification 'Elixir.OMG.Watcher.DB.TxOutput':spend_utxos([map()]) -> 'ok' is a subtype of the success typing: 'Elixir.OMG.Watcher.DB.TxOutput':spend_utxos(_) -> any()
Type specification 'Elixir.OMG.Watcher.DB.TxOutput':create_outputs(pos_integer(),integer(),binary(),'Elixir.OMG.State.Transaction':any_flavor_t()) -> [map()] is a subtype of the success typing: 'Elixir.OMG.Watcher.DB.TxOutput':create_outputs(_,_,_,_) -> any()
Type specification 'Elixir.OMG.Watcher.DB.TxOutput':create_inputs('Elixir.OMG.State.Transaction':any_flavor_t(),binary()) -> [tuple()] is a subtype of the success typing: 'Elixir.OMG.Watcher.DB.TxOutput':create_inputs(_,_) -> any()
Type specification 'Elixir.OMG.Watcher.Eventer.Core':pair_events_with_topics(any() | 'Elixir.OMG.Watcher.Event':t()) -> [{'Elixir.String':t(),'Elixir.String':t(),'Elixir.OMG.Watcher.Event':t()}] is a subtype of the success typing: 'Elixir.OMG.Watcher.Eventer.Core':pair_events_with_topics(_) -> [any()]
Type specification 'Elixir.OMG.Watcher.ExitProcessor':get_active_in_flight_exits() -> {'ok','Elixir.OMG.Watcher.ExitProcessor.Core':in_flight_exits_response_t()} is a subtype of the success typing: 'Elixir.OMG.Watcher.ExitProcessor':get_active_in_flight_exits() -> any()
Type specification 'Elixir.OMG.Watcher.ExitProcessor':get_competitor_for_ife(binary()) -> {'ok','Elixir.OMG.Watcher.ExitProcessor.Core':competitor_data_t()} | {'error','competitor_not_found'} | {'error','no_viable_competitor_found'} is a subtype of the success typing: 'Elixir.OMG.Watcher.ExitProcessor':get_competitor_for_ife(_) -> any()
Type specification 'Elixir.OMG.Watcher.ExitProcessor':prove_canonical_for_ife(binary()) -> {'ok','Elixir.OMG.Watcher.ExitProcessor.Core':prove_canonical_data_t()} | {'error','no_viable_canonical_proof_found'} is a subtype of the success typing: 'Elixir.OMG.Watcher.ExitProcessor':prove_canonical_for_ife(_) -> any()
Type specification 'Elixir.OMG.Watcher.ExitProcessor':get_input_challenge_data('Elixir.OMG.State.Transaction.Signed':tx_bytes(),'Elixir.OMG.State.Transaction':input_index_t()) -> {'ok','Elixir.OMG.Watcher.ExitProcessor.Core':input_challenge_data()} | {'error','Elixir.OMG.Watcher.ExitProcessor.Core':piggyback_challenge_data_error()} is a subtype of the success typing: 'Elixir.OMG.Watcher.ExitProcessor':get_input_challenge_data(_,_) -> any()
Type specification 'Elixir.OMG.Watcher.ExitProcessor':get_output_challenge_data('Elixir.OMG.State.Transaction.Signed':tx_bytes(),'Elixir.OMG.State.Transaction':input_index_t()) -> {'ok','Elixir.OMG.Watcher.ExitProcessor.Core':output_challenge_data()} | {'error','Elixir.OMG.Watcher.ExitProcessor.Core':piggyback_challenge_data_error()} is a subtype of the success typing: 'Elixir.OMG.Watcher.ExitProcessor':get_output_challenge_data(_,_) -> any()
Type specification 'Elixir.OMG.Watcher.ExitProcessor':create_challenge('Elixir.OMG.Utxo.Position':t()) -> {'ok','Elixir.OMG.Watcher.ExitProcessor.StandardExitChallenge':t()} | {'error','utxo_not_spent' | 'exit_not_found'} is a subtype of the success typing: 'Elixir.OMG.Watcher.ExitProcessor':create_challenge(_) -> any()
Type specification 'Elixir.OMG.Watcher.ExitProcessor.Core':handle_spent_blknum_result([spent_blknum_result_t()],['Elixir.OMG.Utxo.Position':t()]) -> [pos_integer()] is a subtype of the success typing: 'Elixir.OMG.Watcher.ExitProcessor.Core':handle_spent_blknum_result(_,_) -> [any()]
Type specification 'Elixir.OMG.Watcher.HttpRPC.Client':get_block(binary(),binary()) -> response_t() is a subtype of the success typing: 'Elixir.OMG.Watcher.HttpRPC.Client':get_block(binary(),_) -> {'error',{'client_error',_} | {'malformed_response',_} | {'server_error',_}} | {'ok',map()}
Type specification 'Elixir.OMG.Watcher.HttpRPC.Client':submit(binary(),binary()) -> response_t() is a subtype of the success typing: 'Elixir.OMG.Watcher.HttpRPC.Client':submit(binary(),_) -> {'error',{'client_error',_} | {'malformed_response',_} | {'server_error',_}} | {'ok',map()}
Type specification 'Elixir.OMG.Watcher.Monitor':pop_child_from_dead_pid(pid(),['Elixir.OMG.Watcher.Monitor.Child':t()]) -> {'Elixir.OMG.Watcher.Monitor.Child':t(),['Elixir.OMG.Watcher.Monitor.Child':t()]} | {'nil',['Elixir.OMG.Watcher.Monitor.Child':t()]} is a subtype of the success typing: 'Elixir.OMG.Watcher.Monitor':pop_child_from_dead_pid(_,[any()]) -> {_,[any()]}
Type specification 'Elixir.OMG.Watcher.TestHelper':decode16(map(),[any()]) -> map() is a subtype of the success typing: 'Elixir.OMG.Watcher.TestHelper':decode16(_,_) -> map()
